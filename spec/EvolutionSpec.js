// Generated by CoffeeScript 1.7.1
(function() {
  describe("Evolution", function() {
    describe("initialization", function() {
      var evolution, fitnessFunction, population;
      evolution = void 0;
      population = void 0;
      fitnessFunction = void 0;
      beforeEach(function() {
        var crossoverRate, i, mutationRate;
        population = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i <= 10; i = ++_i) {
            _results.push(new Individual().genome);
          }
          return _results;
        })();
        fitnessFunction = function(genome) {
          return genome.reduce(function(previous, current, index, array) {
            return previous + current;
          });
        };
        return evolution = new Evolution(population, fitnessFunction, crossoverRate = 0.7, mutationRate = 0.1);
      });
      it("should have the correct population", function() {
        return expect(evolution.population).toEqual(population);
      });
      it("should be initialized with crossoverRate", function() {
        return expect(evolution.crossoverRate).toEqual(0.7);
      });
      return it("should be initialized with correct fitnessFunction", function() {
        return expect(evolution.fitnessFunction(evolution.population[0])).toEqual(fitnessFunction(evolution.population[0]));
      });
    });
    describe("ranking", function() {
      var evolution, fitnessFunction, population;
      evolution = population = fitnessFunction = void 0;
      beforeEach(function() {
        var crossoverRate;
        population = [[1, 1, 1], [2, 2, 2], [3, 3, 3]];
        fitnessFunction = (function(_this) {
          return function(genome) {
            return genome.reduce(function(previous, current, index, array) {
              return previous + current;
            });
          };
        })(this);
        return evolution = new Evolution(population, fitnessFunction, crossoverRate = 0.7);
      });
      return it("should return the genome with the best fitness", function() {
        return expect(evolution.best()).toEqual([3, 3, 3]);
      });
    });
    describe("tournamentSelection()", function() {
      var evolution, fitnessFunction, population;
      evolution = population = fitnessFunction = void 0;
      beforeEach(function() {
        var crossoverRate;
        population = [[1, 1, 1], [2, 2, 2], [3, 3, 3], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]];
        fitnessFunction = (function(_this) {
          return function(genome) {
            return genome.reduce(function(previous, current, index, array) {
              return previous + current;
            });
          };
        })(this);
        return evolution = new Evolution(population, fitnessFunction, crossoverRate = 0.3);
      });
      return it("should return a factor of crossoverRate parents", function() {
        return expect(evolution.tournamentSelection().length).toEqual(3);
      });
    });
    return describe("evolution works", function() {
      var evolution, fitnessFunction, population, winner;
      winner = evolution = population = fitnessFunction = void 0;
      beforeEach(function() {
        var children, crossoverRate, generations, genome, i, mutations, parents, randomIndex, x, _i, _j, _results;
        population = [];
        for (i = _i = 0; _i < 10; i = ++_i) {
          population.push((function() {
            var _j, _results;
            _results = [];
            for (x = _j = 0; _j < 10; x = ++_j) {
              _results.push(Math.random() < 0.5 ? 1 : 0);
            }
            return _results;
          })());
        }
        fitnessFunction = (function(_this) {
          return function(genome) {
            return genome.reduce(function(previous, current, index, array) {
              return previous + current;
            });
          };
        })(this);
        evolution = new Evolution(population, fitnessFunction, crossoverRate = 0.3);
        generations = 0;
        _results = [];
        while (winner === void 0) {
          generations++;
          parents = evolution.tournamentSelection();
          children = [];
          i = 0;
          while (i < parents.length - 1) {
            children.push(Crossover.onePoint(parents[i], parents[i + 1]));
            i++;
          }
          evolution.best();
          evolution.population.slice(evolution.population.length - children.length, evolution.population.length);
          evolution.population.concat(children);
          mutations = Math.round(evolution.population.length * 0.3);
          for (i = _j = 0; 0 <= mutations ? _j <= mutations : _j >= mutations; i = 0 <= mutations ? ++_j : --_j) {
            randomIndex = Crossover.randomIndex(0, evolution.population.length - 1);
            evolution.population[randomIndex] = Mutation.bitFlip(evolution.population[randomIndex]);
          }
          _results.push((function() {
            var _k, _len, _ref, _results1;
            _ref = evolution.population;
            _results1 = [];
            for (_k = 0, _len = _ref.length; _k < _len; _k++) {
              genome = _ref[_k];
              if (fitnessFunction(genome) === 10) {
                winner = genome.slice();
                _results1.push(console.log(generations));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      });
      it("should have a fitness of ten", function() {
        return expect(fitnessFunction(winner)).toEqual(10);
      });
      return it("should have a genome of only 1's", function() {
        return expect(winner).toEqual([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
      });
    });
  });

}).call(this);

//# sourceMappingURL=EvolutionSpec.map
